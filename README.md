# Code Smells Kata

**Smelly Tic Tac Toe**

We created a very smelly implementation of TicTacToe. There are quite a few code smells in the implementation: 

* [Primitive Obsession](https://sourcemaking.com/refactoring/smells/primitive-obsession)  : use of primitives instead of small objects for simple tasks (such as currency, ranges, special strings for phone numbers, etc.). In the `Game` and `Board` classes we use two `int`s and a `char` to model a tile position and content, respectively. *Solution:* introduce a class `Position` (or `Coordinate`) to be used in place of the integer parameters.
* [Feature Envy](https://sourcemaking.com/refactoring/smells/feature-envy)              : method `Board()` of class `Board` accesses the data of class `Tile` more than its own data. *Solution:* [Extract Method](https://sourcemaking.com/refactoring/extract-method), so make the constructor of class `Tile` and remove code from `Board()`. In addition, use [Move Method](https://sourcemaking.com/refactoring/move-method).
* [Data Class](https://sourcemaking.com/refactoring/smells/data-class)                   : class `Tile` contains only fields and doesn't have any method at all, so it is simply a container for data used by other classes. *Solution:* first [Encapsulate Field](https://sourcemaking.com/refactoring/encapsulate-field), so put fields `private` and create getters and setters, then [Move Method](https://sourcemaking.com/refactoring/move-method)s, so find functionality that would be better located in the data class itself. Beware of [Encapsulate Collection](https://sourcemaking.com/refactoring/encapsulate-collection).
* [Message Chains](https://sourcemaking.com/refactoring/smells/message-chains)          : in class `Game` the call `_board.TileAt(1, 0).Symbol` (performed a lot of times) is referring to a method of class `Board` which itself accesses a field of class `Tile`. *Solution:* [Hide Delegate](https://sourcemaking.com/refactoring/hide-delegate), so create method `returnSymbolInTileAt()` in class `Board`.
* [Long Method](https://sourcemaking.com/refactoring/smells/long-method)             : in class `Game`, surely method `Winner()`, but also method `Play()`. *Solution:* [Extract Method](https://sourcemaking.com/refactoring/extract-method).
* [Comments](https://sourcemaking.com/refactoring/smells/comments)                 : in class `Game`, methods `Play()` and `Winner()`. *Solution:* [Extract Method](https://sourcemaking.com/refactoring/extract-method)s into meaningful ones.
* [Long Parameter List](https://sourcemaking.com/refactoring/smells/long-parameter-list)  : when a method takes as input more than three or four parameters, like the method `Play` in class `Game`. *Solution:* [Preserve Whole Object](https://sourcemaking.com/refactoring/preserve-whole-object), so pass the whole object to the method, instead of all its fields. So, like in the smell *Primitive obsession*, create a class `Position` and pass it instead of the two integers.
* [Shotgun Surgery](https://sourcemaking.com/refactoring/smells/shotgun-surgery)       :  for example, if one has to change the name of the field `Symbol` in the class `Tile`, (s)he has to change all the three classes, since the field is directly accessed. *Solution:* create a getter method that takes care of accessing the field. As another example, the class `Board` is set up for a $3 \times 3$ board, if one would do a bigger board (s)he has to do many changes throughout the code, for instance at the constructor `Board()` and at the method `Winner()`. *Solution:* code it in a way that lets you change one single variable to make a bigger board.
* [Duplicate Code](https://sourcemaking.com/refactoring/smells/duplicate-code)         : massive duplication in method `Winner()` in class `Game`. *Solution:* [Extract Method](https://sourcemaking.com/refactoring/extract-method)s and reuse them using calls.
* [Large Class](https://sourcemaking.com/refactoring/smells/large-class)                 : surely class `Game`,  but also class `Board`. *Solution:* [Extract Class](https://sourcemaking.com/refactoring/extract-class).
* [Divergent Change](https://sourcemaking.com/refactoring/smells/divergent-change)     : many changes are made to a single class, reference from [sourcemaking.com](http://sourcemaking.com/) (or "One class is commonly changed in different ways for different reasons." according to the book *Agile Technical Practices Distilled*). 
  According to the second definition, it appears in the class `Game`, since we have to change it every time that we modify something in `Board` or `Tile`. *Solution:* split up the behavior of the class via [Extract Class](https://sourcemaking.com/refactoring/extract-class), or, if different classes have the same behavior, one may want to combine the classes through inheritance ([Extract Superclass](https://sourcemaking.com/refactoring/extract-superclass) and [Extract Subclass](https://sourcemaking.com/refactoring/extract-subclass)).
  Anyway, this is not a strong smell like others in this example.
* [Data Clumps](https://sourcemaking.com/refactoring/smells/data-clumps)              : different parts of the code contain identical groups of variables: the pair of variables `int x`, `int y` appears in different classes and methods. *Solution:* introduce a class `Position` (or `Coordinate`) to be used in place of the integer parameters, like in the smells *Primitive obsession* and *Long Parameter List*.
* [Lazy Class](https://sourcemaking.com/refactoring/smells/lazy-class)                   : class `Tile`is too small and doesn't have any method. *Solution:* [Move Method](https://sourcemaking.com/refactoring/move-method)s, so find functionality that would be better located in the class itself. I wouldn't remove this class, since it is useful when class `Board` creates an `ArrayList` of `Tile`s.
* [Dead Code](https://sourcemaking.com/refactoring/smells/dead-code)                 : the first four lines in method `AddTileAt()` are useless. *Solution:* remove them.

Start by identifying the smells and then slowly refactor the code. Remember to keep the tests passing at all times during the refactor. It's ok to revert back to a previous working state at any moment.
